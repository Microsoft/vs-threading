<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en-US" target-language="fr" original="../Strings.resx">
    <body>
      <trans-unit id="AwaitXInstead" translate="yes" xml:space="preserve">
        <source>Await {0} instead</source>
        <target state="translated">Attendre {0} à la place</target>
        <note from="MultilingualBuild" annotates="source" priority="2">"await" is a C# keyword and should not be translated.
{0} is a method name.</note>
      </trans-unit>
      <trans-unit id="SystemIAsyncDisposablePackageNote">
        <source>The System.IAsyncDisposable interface is defined in the Microsoft.Bcl.AsyncInterfaces NuGet package.</source>
        <target state="translated">L'interface System.IAsyncDisposable est définie dans le package NuGet Microsoft.Bcl.AsyncInterfaces.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAwaitInstead" translate="yes" xml:space="preserve">
        <source>Use await instead</source>
        <target state="translated">Utiliser await à la place</target>
        <note from="MultilingualBuild" annotates="source" priority="2">"await" is a C# keyword and should not be translated.</note>
      </trans-unit>
      <trans-unit id="VSTHRD001_MessageFormat" translate="yes" xml:space="preserve">
        <source>Await JoinableTaskFactory.SwitchToMainThreadAsync() to switch to the UI thread instead of APIs that can deadlock or require specifying a priority.</source>
        <target state="translated">Attendez que JoinableTaskFactory.SwitchToMainThreadAsync() passe au thread d'interface utilisateur au lieu des API susceptibles de se bloquer ou de demander une priorité.</target>
        <note />
      </trans-unit>
      <trans-unit id="VSTHRD001_Title" translate="yes" xml:space="preserve">
        <source>Avoid legacy thread switching APIs</source>
        <target state="translated">Éviter les API de commutation de thread héritées</target>
        <note from="MultilingualBuild" annotates="source" priority="2">thread switching APIs refers to Visual Studio SDK or .NET methods that can be used to switch threads, but are obsolete and should be avoided.</note>
      </trans-unit>
      <trans-unit id="VSTHRD002_CodeFix_Await_Title" translate="yes" xml:space="preserve">
        <source>Use await instead</source>
        <target state="translated">Utiliser await à la place</target>
        <note from="MultilingualBuild" annotates="source" priority="2">"await" is a C# keyword and should not be translated.</note>
      </trans-unit>
      <trans-unit id="VSTHRD002_MessageFormat" translate="yes" xml:space="preserve">
        <source>Synchronously waiting on tasks or awaiters may cause deadlocks. Use await or JoinableTaskFactory.Run instead.</source>
        <target state="translated">L'attente de manière synchrone de tâches ou d’éléments en attente peut entraîner des blocages. Utilisez await ou JoinableTaskFactory.Run à la place.</target>
        <note from="MultilingualBuild" annotates="source" priority="2">"await" is a C# keyword and should not be translated.</note>
      </trans-unit>
      <trans-unit id="VSTHRD002_Title" translate="yes" xml:space="preserve">
        <source>Avoid problematic synchronous waits</source>
        <target state="translated">Éviter les attentes synchrones problématiques</target>
        <note />
      </trans-unit>
      <trans-unit id="VSTHRD003_MessageFormat" translate="yes" xml:space="preserve">
        <source>Avoid awaiting or returning a Task representing work that was not started within your context as that can lead to deadlocks.
Start the work within this context, or use JoinableTaskFactory.RunAsync to start the task and await the returned JoinableTask instead.</source>
        <target state="translated">Évitez d'attendre ou de retourner une tâche représentant un travail non démarré dans votre contexte, car cela peut provoquer des interblocages.
Démarrez le travail dans ce contexte, ou utilisez JoinableTaskFactory.RunAsync pour commencer la tâche, et attendez plutôt le JoinableTask retourné.</target>
        <note from="MultilingualUpdate" annotates="source" priority="2" />
      </trans-unit>
      <trans-unit id="VSTHRD003_Title" translate="yes" xml:space="preserve">
        <source>Avoid awaiting foreign Tasks</source>
        <target state="translated">Éviter d'attendre des tâches étrangères</target>
        <note from="MultilingualUpdate" annotates="source" priority="2" />
      </trans-unit>
      <trans-unit id="VSTHRD004_MessageFormat" translate="yes" xml:space="preserve">
        <source>Calls to JoinableTaskFactory.SwitchToMainThreadAsync() must be awaited.</source>
        <target state="translated">Vous devez attendre les appels à JoinableTaskFactory.SwitchToMainThreadAsync().</target>
        <note />
      </trans-unit>
      <trans-unit id="VSTHRD004_Title" translate="yes" xml:space="preserve">
        <source>Await SwitchToMainThreadAsync</source>
        <target state="translated">Attendre SwitchToMainThreadAsync</target>
        <note from="MultilingualBuild" annotates="source" priority="2">Do not translate either of these. The first is a keyword, the second is a method name.</note>
      </trans-unit>
      <trans-unit id="VSTHRD010_MessageFormat_Async" translate="yes" xml:space="preserve">
        <source>Accessing "{0}" should only be done on the main thread. Await JoinableTaskFactory.SwitchToMainThreadAsync() first.</source>
        <target state="translated">L'accès à "{0}" doit être uniquement effectué sur le thread principal. Attendez d'abord JoinableTaskFactory.SwitchToMainThreadAsync().</target>
        <note from="MultilingualBuild" annotates="source" priority="2">{0} is a type or member name.</note>
      </trans-unit>
      <trans-unit id="VSTHRD010_MessageFormat_Sync" translate="yes" xml:space="preserve">
        <source>Accessing "{0}" should only be done on the main thread. Call {1}() first.</source>
        <target state="translated">L'accès à "{0}" doit être uniquement effectué sur le thread principal. Appelez d'abord {1}().</target>
        <note from="MultilingualBuild" annotates="source" priority="2">{0} is a type or member name and {1} is the name of a method that throws if not called from the main thread.</note>
      </trans-unit>
      <trans-unit id="VSTHRD010_Title" translate="yes" xml:space="preserve">
        <source>Invoke single-threaded types on Main thread</source>
        <target state="translated">Appeler les types à thread unique sur le thread principal</target>
        <note />
      </trans-unit>
      <trans-unit id="VSTHRD011_MessageFormat" translate="yes" xml:space="preserve">
        <source>Lazy&lt;Task&lt;T&gt;&gt;.Value can deadlock.
Use AsyncLazy&lt;T&gt; instead.</source>
        <target state="translated">Lazy&lt;Task&lt;T&gt;&gt;.Value peut entraîner un interblocage.
Utilisez AsyncLazy&lt;T&gt; à la place.</target>
        <note />
      </trans-unit>
      <trans-unit id="VSTHRD011_Title" translate="yes" xml:space="preserve">
        <source>Use AsyncLazy&lt;T&gt;</source>
        <target state="translated">Utiliser AsyncLazy&lt;T&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="VSTHRD011b_MessageFormat" translate="yes" xml:space="preserve">
        <source>Invoking or blocking on async code in a Lazy&lt;T&gt; value factory can deadlock.
Use AsyncLazy&lt;T&gt; instead.</source>
        <target state="translated">L'appel ou le blocage de code asynchrone dans une fabrique de valeurs Lazy&lt;T&gt; peut entraîner un interblocage.
Utilisez AsyncLazy&lt;T&gt; à la place.</target>
        <note />
      </trans-unit>
      <trans-unit id="VSTHRD012_MessageFormat" translate="yes" xml:space="preserve">
        <source>Provide an instance of JoinableTaskFactory in this call (or another overload) to avoid deadlocks with the main thread.</source>
        <target state="translated">Fournissez une instance de JoinableTaskFactory dans cet appel (ou une autre surcharge) pour éviter les blocages avec le même thread.</target>
        <note />
      </trans-unit>
      <trans-unit id="VSTHRD012_Title" translate="yes" xml:space="preserve">
        <source>Provide JoinableTaskFactory where allowed</source>
        <target state="translated">Fournir JoinableTaskFactory quand autorisé</target>
        <note />
      </trans-unit>
      <trans-unit id="VSTHRD100_CodeFix_Title" translate="yes" xml:space="preserve">
        <source>Change return type to Task</source>
        <target state="translated">Remplacer le type de retour par Task</target>
        <note from="MultilingualBuild" annotates="source" priority="2">Task is a type name and should not be translated.</note>
      </trans-unit>
      <trans-unit id="VSTHRD100_MessageFormat" translate="yes" xml:space="preserve">
        <source>Avoid "async void" methods, because any exceptions not handled by the method will crash the process.</source>
        <target state="translated">Évitez les méthodes "async void", car toute exception non traitée par la méthode bloque le processus.</target>
        <note from="MultilingualBuild" annotates="source" priority="2">"async void" is a pair of C# keywords. Do not translate them.</note>
      </trans-unit>
      <trans-unit id="VSTHRD100_Title" translate="yes" xml:space="preserve">
        <source>Avoid async void methods</source>
        <target state="translated">Éviter les méthodes async void</target>
        <note from="MultilingualBuild" annotates="source" priority="2">"async void" is a pair of C# keywords. Do not translate them.</note>
      </trans-unit>
      <trans-unit id="VSTHRD101_MessageFormat" translate="yes" xml:space="preserve">
        <source>Avoid using async lambda for a void returning delegate type, because any exceptions not handled by the delegate will crash the process.</source>
        <target state="translated">Évitez d’utiliser une expression lambda asynchrone pour un type de délégué retournant void, car toute exception non traitée par la méthode bloque le processus.</target>
        <note from="MultilingualBuild" annotates="source" priority="2">"void" is a C# keyword and should not be translated.</note>
      </trans-unit>
      <trans-unit id="VSTHRD101_Title" translate="yes" xml:space="preserve">
        <source>Avoid unsupported async delegates</source>
        <target state="translated">Éviter les délégués async non pris en charge</target>
        <note />
      </trans-unit>
      <trans-unit id="VSTHRD102_MessageFormat" translate="yes" xml:space="preserve">
        <source>Limit use of synchronously blocking method calls such as JoinableTaskFactory.Run or Task.Result to public entrypoint members where you must be synchronous. Using it for internal members can needlessly add synchronous frames between asynchronous frames, leading to threadpool exhaustion.</source>
        <target state="translated">Limitez l'utilisation des appels de méthode de blocage synchrones, comme JoinableTaskFactory.Run ou Task.Result, aux membres de point d’entrée publics où il est nécessaire d’être synchrone. Son utilisation pour des membres internes peut inutilement ajouter des frames synchrones entre les frames asynchrones, provoquant l'épuisement du pool de threads.</target>
        <note />
      </trans-unit>
      <trans-unit id="VSTHRD102_Title" translate="yes" xml:space="preserve">
        <source>Implement internal logic asynchronously</source>
        <target state="translated">Implémenter la logique interne de façon asynchrone</target>
        <note />
      </trans-unit>
      <trans-unit id="VSTHRD103_MessageFormat" translate="yes" xml:space="preserve">
        <source>{0} synchronously blocks. Await {1} instead.</source>
        <target state="translated">{0} bloque de façon synchrone. Attendez {1} à la place.</target>
        <note />
      </trans-unit>
      <trans-unit id="VSTHRD103_MessageFormat_UseAwaitInstead" translate="yes" xml:space="preserve">
        <source>{0} synchronously blocks. Use await instead.</source>
        <target state="translated">{0} bloque de façon synchrone. Utilisez await à la place</target>
        <note />
      </trans-unit>
      <trans-unit id="VSTHRD103_Title" translate="yes" xml:space="preserve">
        <source>Call async methods when in an async method</source>
        <target state="translated">Appeler des méthodes async dans une méthode async</target>
        <note />
      </trans-unit>
      <trans-unit id="VSTHRD104_MessageFormat" translate="yes" xml:space="preserve">
        <source>Expose an async version of this method that does not synchronously block. Then simplify this method to call that async method within a JoinableTaskFactory.Run delegate.</source>
        <target state="translated">Exposez une version asynchrone de cette méthode qui ne se bloque pas de manière synchrone. Ensuite, simplifiez cette méthode pour appeler cette méthode async dans un délégué JoinableTaskFactory.Run.</target>
        <note />
      </trans-unit>
      <trans-unit id="VSTHRD104_Title" translate="yes" xml:space="preserve">
        <source>Offer async methods</source>
        <target state="translated">Offrir des méthodes async</target>
        <note />
      </trans-unit>
      <trans-unit id="VSTHRD105_MessageFormat" translate="yes" xml:space="preserve">
        <source>Avoid method overloads that assume TaskScheduler.Current. Use an overload that accepts a TaskScheduler and specify TaskScheduler.Default (or any other) explicitly.</source>
        <target state="translated">Évitez les surcharges de méthode qui optent par défaut pour TaskScheduler.Current. Utilisez une surcharge qui accepte un TaskScheduler et spécifiez TaskScheduler.Default (ou autre chose) de manière explicite.</target>
        <note />
      </trans-unit>
      <trans-unit id="VSTHRD105_Title" translate="yes" xml:space="preserve">
        <source>Avoid method overloads that assume TaskScheduler.Current</source>
        <target state="translated">Éviter les surcharges de méthode qui optent par défaut pour TaskScheduler.Current</target>
        <note />
      </trans-unit>
      <trans-unit id="VSTHRD106_MessageFormat" translate="yes" xml:space="preserve">
        <source>AsyncEventHandler delegates should be invoked via the extension method "TplExtensions.InvokeAsync()" defined in Microsoft.VisualStudio.Threading assembly.</source>
        <target state="translated">Les délégués AsyncEventHandler doivent être appelés avec la méthode d’extension "TplExtensions.InvokeAsync()" définie dans l’assembly Microsoft.VisualStudio.Threading.</target>
        <note />
      </trans-unit>
      <trans-unit id="VSTHRD106_Title" translate="yes" xml:space="preserve">
        <source>Use InvokeAsync to raise async events</source>
        <target state="translated">Utiliser InvokeAsync pour déclencher des événements async</target>
        <note />
      </trans-unit>
      <trans-unit id="VSTHRD107_CodeFix_Title" translate="yes" xml:space="preserve">
        <source>Await using expression</source>
        <target state="translated">Attendre l’expression using</target>
        <note from="MultilingualBuild" annotates="source" priority="2">"await" and "using" are C# keywords and should not be translated.</note>
      </trans-unit>
      <trans-unit id="VSTHRD107_MessageFormat" translate="yes" xml:space="preserve">
        <source>Missing await operator for "using" expression.</source>
        <target state="translated">Opérateur await manquant pour l’expression "using".</target>
        <note from="MultilingualBuild" annotates="source" priority="2">"await" and "using" are C# keywords and should not be translated.</note>
      </trans-unit>
      <trans-unit id="VSTHRD107_Title" translate="yes" xml:space="preserve">
        <source>Await Task within using expression</source>
        <target state="translated">Tâche Await dans l’expression using</target>
        <note from="MultilingualBuild" annotates="source" priority="2">"await Task" is a C# compound term, and "using" is a C# keyword. These should not be translated.</note>
      </trans-unit>
      <trans-unit id="VSTHRD108_MessageFormat" translate="yes" xml:space="preserve">
        <source>Thread affinity checks should be unconditional.</source>
        <target state="translated">Les vérifications d'affinité de thread doivent être inconditionnelles.</target>
        <note />
      </trans-unit>
      <trans-unit id="VSTHRD108_Title" translate="yes" xml:space="preserve">
        <source>Assert thread affinity unconditionally</source>
        <target state="translated">Effectuer l'assertion de l'affinité de thread de manière inconditionnelle</target>
        <note />
      </trans-unit>
      <trans-unit id="VSTHRD109_MessageFormat" translate="yes" xml:space="preserve">
        <source>Avoid throwing when not on the main thread while in an async or Task-returning method. Switch to the thread required instead.</source>
        <target state="translated">Évitez toute levée quand vous n'êtes pas sur the thread principal dans une méthode retournant async ou Task. Basculez plutôt sur le thread requis.</target>
        <note />
      </trans-unit>
      <trans-unit id="VSTHRD109_Title" translate="yes" xml:space="preserve">
        <source>Switch instead of assert in async methods</source>
        <target state="translated">Basculer sur des méthodes async plutôt qu'assert</target>
        <note />
      </trans-unit>
      <trans-unit id="VSTHRD110_MessageFormat" translate="yes" xml:space="preserve">
        <source>Observe the awaitable result of this method call by awaiting it, assigning to a variable, or passing it to another method.</source>
        <target state="translated">Observez le résultat pouvant être attendu de cet appel de méthode en l'attendant, en l'assignant à une variable ou en le passant à une autre méthode.</target>
        <note />
      </trans-unit>
      <trans-unit id="VSTHRD110_Title" translate="yes" xml:space="preserve">
        <source>Observe result of async calls</source>
        <target state="translated">Observer le résultat des appels async</target>
        <note />
      </trans-unit>
      <trans-unit id="VSTHRD111_CodeFix_False_Title" translate="yes" xml:space="preserve">
        <source>Add .ConfigureAwait(false)</source>
        <target state="translated">Ajouter .ConfigureAwait(false)</target>
        <note from="MultilingualBuild" annotates="source" priority="2">".ConfigureAwait(false)" should not be translated.</note>
      </trans-unit>
      <trans-unit id="VSTHRD111_CodeFix_True_Title" translate="yes" xml:space="preserve">
        <source>Add .ConfigureAwait(true)</source>
        <target state="translated">Ajouter .ConfigureAwait(true)</target>
        <note from="MultilingualBuild" annotates="source" priority="2">".ConfigureAwait(true)" should not be translated.</note>
      </trans-unit>
      <trans-unit id="VSTHRD111_MessageFormat" translate="yes" xml:space="preserve">
        <source>Add .ConfigureAwait(bool) to your await expression.</source>
        <target state="translated">Ajoutez .ConfigureAwait(bool) à votre expression await.</target>
        <note from="MultilingualBuild" annotates="source" priority="2">".ConfigureAwait(bool)" and "await" should NOT be translated.</note>
      </trans-unit>
      <trans-unit id="VSTHRD111_Title" translate="yes" xml:space="preserve">
        <source>Use ConfigureAwait(bool)</source>
        <target state="translated">Utiliser ConfigureAwait(bool)</target>
        <note from="MultilingualBuild" annotates="source" priority="2">"ConfigureAwait(bool)" is a reference and should NOT be translated.</note>
      </trans-unit>
      <trans-unit id="VSTHRD112_CodeFix_Title">
        <source>Add implementation of System.IAsyncDisposable.</source>
        <target state="translated">Ajoutez l'implémentation de System.IAsyncDisposable.</target>
        <note />
      </trans-unit>
      <trans-unit id="VSTHRD112_MessageFormat">
        <source>Implement the System.IAsyncDisposable interface when implementing the obsolete Microsoft.VisualStudio.Threading.IAsyncDisposable interface.</source>
        <target state="translated">Implémentez l'interface System.IAsyncDisposable quand vous implémentez l'interface Microsoft.VisualStudio.Threading.IAsyncDisposable obsolète.</target>
        <note />
      </trans-unit>
      <trans-unit id="VSTHRD112_Title">
        <source>Implement System.IAsyncDisposable</source>
        <target state="translated">Implémentez System.IAsyncDisposable</target>
        <note />
      </trans-unit>
      <trans-unit id="VSTHRD113_MessageFormat">
        <source>Add a check for System.IAsyncDisposable in the same code block that checks for Microsoft.VisualStudio.Threading.IAsyncDisposable that behaves similarly.</source>
        <target state="translated">Ajoutez une vérification de System.IAsyncDisposable dans le même bloc de code qui vérifie Microsoft.VisualStudio.Threading.IAsyncDisposable dont le comportement est similaire.</target>
        <note />
      </trans-unit>
      <trans-unit id="VSTHRD113_Title">
        <source>Check for System.IAsyncDisposable</source>
        <target state="translated">Vérifier System.IAsyncDisposable</target>
        <note />
      </trans-unit>
      <trans-unit id="VSTHRD114_CodeFix_CompletedTask">
        <source>Use 'Task.CompletedTask' instead</source>
        <target state="translated">Utiliser 'Task.CompletedTask' à la place</target>
        <note>"Task.CompletedTask" should not be translated.</note>
      </trans-unit>
      <trans-unit id="VSTHRD114_CodeFix_FromResult">
        <source>Use 'Task.FromResult' instead</source>
        <target state="translated">Utiliser 'Task.FromResult' à la place</target>
        <note>"Task.FromResult" should not be translated.</note>
      </trans-unit>
      <trans-unit id="VSTHRD114_MessageFormat">
        <source>Avoid returning null from a Task-returning method.</source>
        <target state="translated">Évitez de retourner la valeur null pour une méthode qui retourne une tâche.</target>
        <note>Task is a type name and should not be translated.</note>
      </trans-unit>
      <trans-unit id="VSTHRD114_Title">
        <source>Avoid returning a null Task</source>
        <target state="translated">Éviter de retourner une tâche null</target>
        <note>Task is a type name and should not be translated.</note>
      </trans-unit>
      <trans-unit id="VSTHRD200_AddAsync_MessageFormat" translate="yes" xml:space="preserve">
        <source>Use "Async" suffix in names of methods that return an awaitable type.</source>
        <target state="translated">Utilisez le suffixe "Async" dans les noms des méthodes qui retournent un type awaitable.</target>
        <note />
      </trans-unit>
      <trans-unit id="VSTHRD200_CodeFix_Title" translate="yes" xml:space="preserve">
        <source>Rename to {0}</source>
        <target state="translated">Renommer en {0}</target>
        <note from="MultilingualBuild" annotates="source" priority="2">{0} is a method name.</note>
      </trans-unit>
      <trans-unit id="VSTHRD200_RemoveAsync_MessageFormat" translate="yes" xml:space="preserve">
        <source>Avoid "Async" suffix in names of methods that do not return an awaitable type.</source>
        <target state="translated">Évitez le suffixe "Async" dans les noms des méthodes qui ne retournent pas un type awaitable</target>
        <note />
      </trans-unit>
      <trans-unit id="VSTHRD200_Title" translate="yes" xml:space="preserve">
        <source>Use "Async" suffix for async methods</source>
        <target state="translated">Utiliser le suffixe "Async" pour les méthodes asynchrones</target>
        <note />
      </trans-unit>
      <trans-unit id="VSTHRD201_CodeFix_Title">
        <source>Call ThrowIfCancellationRequested()</source>
        <target state="translated">Appeler ThrowIfCancellationRequested()</target>
        <note>"ThrowIfCancellationRequested" is a method name and should not be translated.</note>
      </trans-unit>
      <trans-unit id="VSTHRD201_MessageFormat">
        <source>Check for cancellation after calling SwitchToMainThreadAsync(CancellationToken).</source>
        <target state="translated">Vérifiez l’annulation après l’appel de SwitchToMainThreadAsync (CancellationToken).</target>
        <note>"SwitchToMainThreadAsync" is a method name and should not be translated.</note>
      </trans-unit>
      <trans-unit id="VSTHRD201_Title">
        <source>Check cancellation after SwitchToMainThreadAsync</source>
        <target state="translated">Vérifier l’annulation après SwitchToMainThreadAsync</target>
        <note>"SwitchToMainThreadAsync" is a method name and should not be translated.</note>
      </trans-unit>
    </body>
  </file>
</xliff>